/* (C)2023 */
package org.transitclock.core.domain;

import lombok.Data;
import org.springframework.data.annotation.Transient;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;
import org.transitclock.applications.Core;

import java.io.Serializable;
import java.util.Date;

/**
 * A database object for persisting information on how accurate a prediction was compared to the
 * actual measured arrival/departure time for the vehicle.
 *
 * <p>Serializable since Hibernate requires such.
 *
 * <p>Implements Lifecycle so that can have the onLoad() callback be called when reading in data so
 * that can intern() member strings. In order to do this the String members could not be declared as
 * final since they are updated after the constructor is called.
 *
 * @author SkiBu Smith
 */
@Data
@Document(collection = "PredictionAccuracy")
public class PredictionAccuracy implements Serializable {

    // Need an ID but using regular columns doesn't really make
    // sense. So use an auto generated one. Not final since
    // autogenerated and therefore not set in constructor.
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private long id;

    // Not declared final since using intern() when reading from db
    private String routeId;

    // routeShortName is included because for some agencies the
    // route_id changes when there are schedule updates. But the
    // routeShortName is more likely to stay consistent. Therefore
    // it is better for when querying for arrival/departure data
    // over a time span.
    // Not declared final since using intern() when reading from db
    private String routeShortName;

    // Not declared final since using intern() when reading from db
    private String directionId;

    // Not declared final since using intern() when reading from db
    private String stopId;

    // So can see which trip predictions for so can easily determine
    // what the travel times are and see if they appear to be correct.
    // Not declared final since using intern() when reading from db
    private String tripId;

    // The actual arrival time that corresponds to the prediction time
    @Indexed(name = "PredictionAccuracyTimeIndex")
    private final Date arrivalDepartureTime;

    // The predicted time the vehicle was expected to arrive/depart the stop
    private final Date predictedTime;

    // The time the prediction was read. This allows us to determine
    // how far out into the future the prediction is for.
    private final Date predictionReadTime;

    // Positive means vehicle arrived at stop later then predicted for and
    // negative value means vehicle arrived earlier.
    private final int predictionAccuracyMsecs;

    private String predictionSource;

    // @Column(length=60)
    @Transient
    private String predictionAlgorithm;

    private String vehicleId;

    private final Boolean affectedByWaitStop;

    public PredictionAccuracy(
            String routeId,
            String directionId,
            String stopId,
            String tripId,
            Date arrivalDepartureTime,
            Date predictedTime,
            Date predictionReadTime,
            String predictionSource,
            String predictionAlgorithm,
            String vehicleId,
            Boolean affectedByWaitStop) {
        this.routeId = routeId;

        Route route = Core.getInstance().getDbConfig().getRouteById(routeId);
        this.routeShortName = route.getShortName();
        this.directionId = directionId;
        this.stopId = stopId;
        this.tripId = tripId;
        this.arrivalDepartureTime = arrivalDepartureTime;
        this.predictedTime = predictedTime;
        this.predictionReadTime = predictionReadTime;
        this.predictionAccuracyMsecs =
                arrivalDepartureTime != null ? (int) (arrivalDepartureTime.getTime() - predictedTime.getTime()) : 0;
        this.predictionSource = predictionSource;
        this.vehicleId = vehicleId;
        this.affectedByWaitStop = affectedByWaitStop;
        this.predictionAlgorithm = predictionAlgorithm;
    }

    public int getPredictionLengthMsecs() {
        return (int) (predictedTime.getTime() - predictionReadTime.getTime());
    }

    /**
     * True if the prediction is based on scheduled departure time, false if not. Null if feed of
     * predictions doesn't provide that information.
     *
     * @return
     */
    public Boolean isAffectedByWaitStop() {
        return affectedByWaitStop;
    }
}
