/* (C)2023 */
package org.transitclock.db.structs;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;
import org.hibernate.CallbackException;
import org.hibernate.Session;
import org.hibernate.annotations.DynamicUpdate;
import org.hibernate.classic.Lifecycle;
import org.transitclock.applications.Core;

import javax.persistence.*;
import java.io.Serializable;
import java.util.Date;

/**
 * A database object for persisting information on how accurate a prediction was compared to the
 * actual measured arrival/departure time for the vehicle.
 *
 * <p>Serializable since Hibernate requires such.
 *
 * <p>Implements Lifecycle so that can have the onLoad() callback be called when reading in data so
 * that can intern() member strings. In order to do this the String members could not be declared as
 * final since they are updated after the constructor is called.
 *
 * @author SkiBu Smith
 */
@Entity
@DynamicUpdate
@EqualsAndHashCode
@ToString
@Getter
@Table(
        name = "PredictionAccuracy",
        indexes = {@Index(name = "PredictionAccuracyTimeIndex", columnList = "arrivalDepartureTime")})
public class PredictionAccuracy implements Lifecycle, Serializable {

    // Need an ID but using regular columns doesn't really make
    // sense. So use an auto generated one. Not final since
    // autogenerated and therefore not set in constructor.
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private long id;

    // Not declared final since using intern() when reading from db
    @Column(length = 60)
    private String routeId;

    // routeShortName is included because for some agencies the
    // route_id changes when there are schedule updates. But the
    // routeShortName is more likely to stay consistent. Therefore
    // it is better for when querying for arrival/departure data
    // over a time span.
    // Not declared final since using intern() when reading from db
    @Column(length = 60)
    private String routeShortName;

    // Not declared final since using intern() when reading from db
    @Column(length = 60)
    private String directionId;

    // Not declared final since using intern() when reading from db
    @Column(length = 60)
    private String stopId;

    // So can see which trip predictions for so can easily determine
    // what the travel times are and see if they appear to be correct.
    // Not declared final since using intern() when reading from db
    @Column(length = 60)
    private String tripId;

    // The actual arrival time that corresponds to the prediction time
    @Column
    @Temporal(TemporalType.TIMESTAMP)
    private final Date arrivalDepartureTime;

    // The predicted time the vehicle was expected to arrive/depart the stop
    @Column
    @Temporal(TemporalType.TIMESTAMP)
    private final Date predictedTime;

    // The time the prediction was read. This allows us to determine
    // how far out into the future the prediction is for.
    @Column
    @Temporal(TemporalType.TIMESTAMP)
    private final Date predictionReadTime;

    // Positive means vehicle arrived at stop later then predicted for and
    // negative value means vehicle arrived earlier.
    @Column
    private final int predictionAccuracyMsecs;

    @Column(length = 60)
    private String predictionSource;

    /* TODO */
    // @Column(length=60)
    @Transient
    private String predictionAlgorithm;

    @Column(length = 60)
    private String vehicleId;

    @Column
    private final Boolean affectedByWaitStop;

    public PredictionAccuracy(
            String routeId,
            String directionId,
            String stopId,
            String tripId,
            Date arrivalDepartureTime,
            Date predictedTime,
            Date predictionReadTime,
            String predictionSource,
            String predictionAlgorithm,
            String vehicleId,
            Boolean affectedByWaitStop) {
        super();
        this.routeId = routeId;

        Route route = Core.getInstance().getDbConfig().getRouteById(routeId);
        this.routeShortName = route.getShortName();
        this.directionId = directionId;
        this.stopId = stopId;
        this.tripId = tripId;
        this.arrivalDepartureTime = arrivalDepartureTime;
        this.predictedTime = predictedTime;
        this.predictionReadTime = predictionReadTime;
        this.predictionAccuracyMsecs =
                arrivalDepartureTime != null ? (int) (arrivalDepartureTime.getTime() - predictedTime.getTime()) : 0;
        this.predictionSource = predictionSource;
        this.vehicleId = vehicleId;
        this.affectedByWaitStop = affectedByWaitStop;
        this.predictionAlgorithm = predictionAlgorithm;
    }

    protected PredictionAccuracy() {
        super();
        this.routeId = null;
        this.routeShortName = null;
        this.directionId = null;
        this.stopId = null;
        this.tripId = null;
        this.arrivalDepartureTime = null;
        this.predictedTime = null;
        this.predictionReadTime = null;
        this.predictionAccuracyMsecs = -1;
        this.predictionSource = null;
        this.vehicleId = null;
        this.affectedByWaitStop = null;
        this.predictionAlgorithm = null;
    }


    public int getPredictionLengthMsecs() {
        return (int) (predictedTime.getTime() - predictionReadTime.getTime());
    }

    /**
     * True if the prediction is based on scheduled departure time, false if not. Null if feed of
     * predictions doesn't provide that information.
     *
     * @return
     */
    public Boolean isAffectedByWaitStop() {
        return affectedByWaitStop;
    }

    /** Callback due to implementing Lifecycle interface. Used to compact string members by them. */
    @Override
    public void onLoad(Session s, Serializable id) throws CallbackException {
        if (routeId != null) routeId = routeId.intern();
        if (routeShortName != null) routeShortName = routeShortName.intern();
        if (directionId != null) directionId = directionId.intern();
        if (stopId != null) stopId = stopId.intern();
        if (tripId != null) tripId = tripId.intern();
        if (predictionSource != null) predictionSource = predictionSource.intern();
        if (predictionAlgorithm != null) predictionAlgorithm = predictionAlgorithm.intern();
        if (vehicleId != null) vehicleId = vehicleId.intern();
    }

    /** Implemented due to Lifecycle interface being implemented. Not actually used. */
    @Override
    public boolean onSave(Session s) throws CallbackException {
        return Lifecycle.NO_VETO;
    }

    /** Implemented due to Lifecycle interface being implemented. Not actually used. */
    @Override
    public boolean onUpdate(Session s) throws CallbackException {
        return Lifecycle.NO_VETO;
    }

    /** Implemented due to Lifecycle interface being implemented. Not actually used. */
    @Override
    public boolean onDelete(Session s) throws CallbackException {
        return Lifecycle.NO_VETO;
    }
}
